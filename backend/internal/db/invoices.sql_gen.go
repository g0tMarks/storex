// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO app.invoices (agreement_id, due_date, amount, status)
VALUES ($1, $2, $3, $4::app.invoice_status)
RETURNING invoice_id, agreement_id, due_date, amount, status
`

type CreateInvoiceParams struct {
	AgreementID uuid.UUID        `db:"agreement_id" json:"agreementId"`
	DueDate     time.Time        `db:"due_date" json:"dueDate"`
	Amount      string           `db:"amount" json:"amount"`
	Status      AppInvoiceStatus `db:"status" json:"status"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (AppInvoice, error) {
	row := q.db.QueryRowContext(ctx, createInvoice,
		arg.AgreementID,
		arg.DueDate,
		arg.Amount,
		arg.Status,
	)
	var i AppInvoice
	err := row.Scan(
		&i.InvoiceID,
		&i.AgreementID,
		&i.DueDate,
		&i.Amount,
		&i.Status,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM app.invoices WHERE invoice_id = $1::uuid
`

func (q *Queries) DeleteInvoice(ctx context.Context, invoiceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvoice, invoiceID)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT invoice_id, agreement_id, due_date, amount, status FROM app.invoices WHERE invoice_id = $1::uuid
`

func (q *Queries) GetInvoice(ctx context.Context, invoiceID uuid.UUID) (AppInvoice, error) {
	row := q.db.QueryRowContext(ctx, getInvoice, invoiceID)
	var i AppInvoice
	err := row.Scan(
		&i.InvoiceID,
		&i.AgreementID,
		&i.DueDate,
		&i.Amount,
		&i.Status,
	)
	return i, err
}

const listInvoices = `-- name: ListInvoices :many
SELECT invoice_id, agreement_id, due_date, amount, status FROM app.invoices ORDER BY invoice_id DESC
`

func (q *Queries) ListInvoices(ctx context.Context) ([]AppInvoice, error) {
	rows, err := q.db.QueryContext(ctx, listInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppInvoice
	for rows.Next() {
		var i AppInvoice
		if err := rows.Scan(
			&i.InvoiceID,
			&i.AgreementID,
			&i.DueDate,
			&i.Amount,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE app.invoices
SET agreement_id = $1, due_date = $2, amount = $3, status = $4::app.invoice_status
WHERE invoice_id = $5::uuid
RETURNING invoice_id, agreement_id, due_date, amount, status
`

type UpdateInvoiceParams struct {
	AgreementID uuid.UUID        `db:"agreement_id" json:"agreementId"`
	DueDate     time.Time        `db:"due_date" json:"dueDate"`
	Amount      string           `db:"amount" json:"amount"`
	Status      AppInvoiceStatus `db:"status" json:"status"`
	InvoiceID   uuid.UUID        `db:"invoice_id" json:"invoiceId"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (AppInvoice, error) {
	row := q.db.QueryRowContext(ctx, updateInvoice,
		arg.AgreementID,
		arg.DueDate,
		arg.Amount,
		arg.Status,
		arg.InvoiceID,
	)
	var i AppInvoice
	err := row.Scan(
		&i.InvoiceID,
		&i.AgreementID,
		&i.DueDate,
		&i.Amount,
		&i.Status,
	)
	return i, err
}
