// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO app.payments (invoice_id, method, gateway_ref, status)
VALUES ($1, $2, $3, $4::app.payment_status)
RETURNING payment_id, invoice_id, method, gateway_ref, status
`

type CreatePaymentParams struct {
	InvoiceID  uuid.UUID        `db:"invoice_id" json:"invoiceId"`
	Method     sql.NullString   `db:"method" json:"method"`
	GatewayRef sql.NullString   `db:"gateway_ref" json:"gatewayRef"`
	Status     AppPaymentStatus `db:"status" json:"status"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (AppPayment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.InvoiceID,
		arg.Method,
		arg.GatewayRef,
		arg.Status,
	)
	var i AppPayment
	err := row.Scan(
		&i.PaymentID,
		&i.InvoiceID,
		&i.Method,
		&i.GatewayRef,
		&i.Status,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM app.payments WHERE payment_id = $1::uuid
`

func (q *Queries) DeletePayment(ctx context.Context, paymentID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePayment, paymentID)
	return err
}

const getPayment = `-- name: GetPayment :one
SELECT payment_id, invoice_id, method, gateway_ref, status FROM app.payments WHERE payment_id = $1::uuid
`

func (q *Queries) GetPayment(ctx context.Context, paymentID uuid.UUID) (AppPayment, error) {
	row := q.db.QueryRowContext(ctx, getPayment, paymentID)
	var i AppPayment
	err := row.Scan(
		&i.PaymentID,
		&i.InvoiceID,
		&i.Method,
		&i.GatewayRef,
		&i.Status,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT payment_id, invoice_id, method, gateway_ref, status FROM app.payments ORDER BY payment_id DESC
`

func (q *Queries) ListPayments(ctx context.Context) ([]AppPayment, error) {
	rows, err := q.db.QueryContext(ctx, listPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppPayment
	for rows.Next() {
		var i AppPayment
		if err := rows.Scan(
			&i.PaymentID,
			&i.InvoiceID,
			&i.Method,
			&i.GatewayRef,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE app.payments
SET invoice_id = $1, method = $2, gateway_ref = $3, status = $4::app.payment_status
WHERE payment_id = $5::uuid
RETURNING payment_id, invoice_id, method, gateway_ref, status
`

type UpdatePaymentParams struct {
	InvoiceID  uuid.UUID        `db:"invoice_id" json:"invoiceId"`
	Method     sql.NullString   `db:"method" json:"method"`
	GatewayRef sql.NullString   `db:"gateway_ref" json:"gatewayRef"`
	Status     AppPaymentStatus `db:"status" json:"status"`
	PaymentID  uuid.UUID        `db:"payment_id" json:"paymentId"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (AppPayment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment,
		arg.InvoiceID,
		arg.Method,
		arg.GatewayRef,
		arg.Status,
		arg.PaymentID,
	)
	var i AppPayment
	err := row.Scan(
		&i.PaymentID,
		&i.InvoiceID,
		&i.Method,
		&i.GatewayRef,
		&i.Status,
	)
	return i, err
}
