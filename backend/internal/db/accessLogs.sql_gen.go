// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accessLogs.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createAccessLog = `-- name: CreateAccessLog :one
INSERT INTO app.access_logs (customer_id, unit_id, datetime, action)
VALUES ($1, $2, $3, $4)
RETURNING log_id, customer_id, unit_id, datetime, action
`

type CreateAccessLogParams struct {
	CustomerID int64          `db:"customer_id" json:"customerId"`
	UnitID     int64          `db:"unit_id" json:"unitId"`
	Datetime   time.Time      `db:"datetime" json:"datetime"`
	Action     sql.NullString `db:"action" json:"action"`
}

func (q *Queries) CreateAccessLog(ctx context.Context, arg CreateAccessLogParams) (AppAccessLog, error) {
	row := q.db.QueryRowContext(ctx, createAccessLog,
		arg.CustomerID,
		arg.UnitID,
		arg.Datetime,
		arg.Action,
	)
	var i AppAccessLog
	err := row.Scan(
		&i.LogID,
		&i.CustomerID,
		&i.UnitID,
		&i.Datetime,
		&i.Action,
	)
	return i, err
}

const deleteAccessLog = `-- name: DeleteAccessLog :exec
DELETE FROM app.access_logs WHERE log_id = $1
`

func (q *Queries) DeleteAccessLog(ctx context.Context, logID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAccessLog, logID)
	return err
}

const getAccessLogsByCustomer = `-- name: GetAccessLogsByCustomer :many
SELECT log_id, customer_id, unit_id, datetime, action FROM app.access_logs WHERE customer_id = $1 ORDER BY datetime DESC
`

func (q *Queries) GetAccessLogsByCustomer(ctx context.Context, customerID int64) ([]AppAccessLog, error) {
	rows, err := q.db.QueryContext(ctx, getAccessLogsByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAccessLog
	for rows.Next() {
		var i AppAccessLog
		if err := rows.Scan(
			&i.LogID,
			&i.CustomerID,
			&i.UnitID,
			&i.Datetime,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccessLogsByUnit = `-- name: GetAccessLogsByUnit :many
SELECT log_id, customer_id, unit_id, datetime, action FROM app.access_logs WHERE unit_id = $1 ORDER BY datetime DESC
`

func (q *Queries) GetAccessLogsByUnit(ctx context.Context, unitID int64) ([]AppAccessLog, error) {
	rows, err := q.db.QueryContext(ctx, getAccessLogsByUnit, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAccessLog
	for rows.Next() {
		var i AppAccessLog
		if err := rows.Scan(
			&i.LogID,
			&i.CustomerID,
			&i.UnitID,
			&i.Datetime,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccessLogs = `-- name: ListAccessLogs :many
SELECT log_id, customer_id, unit_id, datetime, action FROM app.access_logs ORDER BY datetime DESC
`

func (q *Queries) ListAccessLogs(ctx context.Context) ([]AppAccessLog, error) {
	rows, err := q.db.QueryContext(ctx, listAccessLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAccessLog
	for rows.Next() {
		var i AppAccessLog
		if err := rows.Scan(
			&i.LogID,
			&i.CustomerID,
			&i.UnitID,
			&i.Datetime,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
